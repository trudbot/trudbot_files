//
// Created by kk最棒啦 on 2022/6/18.
//
/*
 一个格斗场内有 n 个战士，其中第 i 个战士的战斗力为 ai。

作为格斗场内的经理人，你需要给战士们安排一对一的决斗。

这些决斗是一场接一场进行的，一场结束后才会安排下一场。

为了保证决斗的观赏性，在安排时需保证：

决斗双方的战斗力不能相同。
决斗双方的战斗力差距不能超过 K。
已知，在决斗中战斗力高的选手一定可以将战斗力低的选手击败，并且失败的选手会被赶出格斗场。

请你合理安排决斗，使得当剩余选手之间无法再安排任何决斗时，剩余选手的数量越少越好。

请你输出剩余选手的最小可能数量。

输入格式
第一行包含两个整数 n,K。

第二行包含 n 个整数 a1,a2,…,an。

输出格式
一个整数，表示剩余选手的最小可能数量。

数据范围
前四个测试点满足 1≤n≤10。
所有测试点满足 1≤n≤2×105，1≤K≤106，1≤ai≤106。

输入样例1：
7 1
101 53 42 102 101 55 54
输出样例1：
3
输入样例2：
6 5
20 15 10 15 20 25
输出样例2：
1
输入样例3：
7 1000000
1 1 1 1 1 1 1
输出样例3：
7
 */
#include <bits/stdc++.h>
using namespace std;

int main() {
    int n, k;
    cin >> n >> k;
    int arr[n];
    for(int i=0; i<n; i++){
        cin >> arr[i];
    }
    sort(arr, arr+n);
    int res = n, curr;
    int i = 0, j = 1;
    for(i; i<n-1; i++) {
        curr = arr[i];
        for(j; j<n; j++) {
            if(arr[j] > curr+k) {
                break;
            }
        }
        if(arr[j-1] != curr){
            res--;
        }
    }
    cout << res << endl;
}

/* 解题思路(贪心 + 双指针)
 * 因为被踢出决斗场的是战斗力低的， 所以可以先将数据排个序， 遍历一般数组， 将所有可以被踢出的选手踢出
 * 思路的正确性在于， 当i选手被踢出时， 战斗力小于i且可以被踢出的选手已经被踢出， 而大于i的选手不可能被i踢出
 * 用i表示当前选手的下标， j为最小的 战斗力大于ai+k的选手的下标
 * 以此为基础， 可知若a(j-1)不等于ai， 则ai可被踢出
 * 若j到达n， 则不再移动， j-1为战斗力最高的选手， 此时战斗力不为a(j-1)的都将踢出， 符合题意
 */
